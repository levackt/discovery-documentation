{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Enigma? \ud83e\udd14 Enigma is a decentralized network that enables Secret Contracts . This means you can create decentralized applications with end-to-end data privacy and strong correctness guarantees. Data inputs, and outputs are encrypted throughout. Even the nodes running the computation can't see the data . Enigma is Ethereum compatible . Secret Contracts can call any function inside a smart contract on Ethereum. Ready to dive in? Get started quickly with our Quick Start guide Build your first secret contract Check out a list of contract ideas Overview \ud83d\udc41\ufe0f [insert diagram here] This diagram illustrates how data flows in an Enigma-based application. Data Flow A secret contract function call is considered a single private computation or task . Secret contracts are registered at deployment on the Enigma Contract (on Ethereum), which the Enigma network watches for new tasks. These tasks are initiated (and paid for) by the end users of Ethereum dApps and are then offloaded from Ethereum into the Enigma network for computation. The Enigma network then selects a worker node to execute the given task in a modified Web Assembly interpreter (WASMI) running inside a Trusted Execution Environment (TEE) using Intel Software Guard Extensions (SGX) technology (also known as an enclave ). After computing a task, a cryptographic proof of the completed task is recorded, and eventually verified, on the Ethereum network. Enigma and Ethereum Enigma and Ethereum work together, and separate computation and storage from consensus. Enigma: Compute and Storage Layer Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys. Ethereum: Consensus Layer Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status. Key Concepts \ud83e\udd1e Secret Contract Task Enigma Contract Enigma JS Library Worker Node What can I do with Enigma? \ud83d\udee0\ufe0f The Discovery release of Enigma has plenty of exciting new features, including secret state , Rust-based secret contracts, private outputs, and more. Some of the applications we're excited about include: Access-control for data (like price predictions or a pointer to an IPFS file) Games where your \"pocket cards\" must stay secret (like Gin Rummy or Poker) Private voting, without a commit-reveal scheme (actually, any use-case with a commit-reveal pattern can be streamlined with Enigma!) Secret inputs to a credit-scoring algorithm Sybil-prevention via social verification -- without exposing your user's data!","title":"About Enigma"},{"location":"#what-is-enigma","text":"Enigma is a decentralized network that enables Secret Contracts . This means you can create decentralized applications with end-to-end data privacy and strong correctness guarantees. Data inputs, and outputs are encrypted throughout. Even the nodes running the computation can't see the data . Enigma is Ethereum compatible . Secret Contracts can call any function inside a smart contract on Ethereum. Ready to dive in? Get started quickly with our Quick Start guide Build your first secret contract Check out a list of contract ideas","title":"What is Enigma? \ud83e\udd14"},{"location":"#overview","text":"[insert diagram here] This diagram illustrates how data flows in an Enigma-based application.","title":"Overview \ud83d\udc41\ufe0f"},{"location":"#data-flow","text":"A secret contract function call is considered a single private computation or task . Secret contracts are registered at deployment on the Enigma Contract (on Ethereum), which the Enigma network watches for new tasks. These tasks are initiated (and paid for) by the end users of Ethereum dApps and are then offloaded from Ethereum into the Enigma network for computation. The Enigma network then selects a worker node to execute the given task in a modified Web Assembly interpreter (WASMI) running inside a Trusted Execution Environment (TEE) using Intel Software Guard Extensions (SGX) technology (also known as an enclave ). After computing a task, a cryptographic proof of the completed task is recorded, and eventually verified, on the Ethereum network.","title":"Data Flow"},{"location":"#enigma-and-ethereum","text":"Enigma and Ethereum work together, and separate computation and storage from consensus.","title":"Enigma and Ethereum"},{"location":"#enigma-compute-and-storage-layer","text":"Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys.","title":"Enigma: Compute and Storage Layer"},{"location":"#ethereum-consensus-layer","text":"Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status. Key Concepts \ud83e\udd1e Secret Contract Task Enigma Contract Enigma JS Library Worker Node","title":"Ethereum: Consensus Layer"},{"location":"#what-can-i-do-with-enigma","text":"The Discovery release of Enigma has plenty of exciting new features, including secret state , Rust-based secret contracts, private outputs, and more. Some of the applications we're excited about include: Access-control for data (like price predictions or a pointer to an IPFS file) Games where your \"pocket cards\" must stay secret (like Gin Rummy or Poker) Private voting, without a commit-reveal scheme (actually, any use-case with a commit-reveal pattern can be streamlined with Enigma!) Secret inputs to a credit-scoring algorithm Sybil-prevention via social verification -- without exposing your user's data!","title":"What can I do with Enigma? \ud83d\udee0\ufe0f"},{"location":"API/","text":"Functions admin() Initialize the worker-specific admin features createContracts(enigmaContractAddr, tokenContractAddr) Initialize the Enigma and Enigma token contracts createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task Create a base Task - a wrapper for a task (either contract deployments or regular tasks) createTaskRecord(task) \u21d2 EventEmitter Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. createTaskRecords(tasks) \u21d2 EventEmitter Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. getTaskRecordStatus(task) \u21d2 Promise Get the Task s task record status from Ethereum getReport(custodian) \u21d2 Promise Find SGX report getWorkerParams(blockNumber) \u21d2 Promise Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array Select the workers weighted-randomly based on the staked token amount that will run the computation task sendTaskInput(task) \u21d2 EventEmitter Send Task to Enigma p2p network for computation getTaskResult(task) \u21d2 EventEmitter Get task result from p2p network pollTaskStatusGen(task, withResult) Generator function for polling the Enigma p2p network for task status innerPollTaskStatus(task, generator, emitter) Inner poll status function that continues to poll the Enigma p2p network until the task has been verified pollTaskStatus(task, withResult) \u21d2 EventEmitter Poll the Enigma p2p network for a TaskInput s status serializeTask(task) \u21d2 Object Serialize Task for submission to the Enigma p2p network obtainTaskKeyPair() \u21d2 Object Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task Create a compute task - creates base task, creates task record, and sends task to the Enigma network. version() \u21d2 string Return the version number of the library admin() Initialize the worker-specific admin features Kind : global function createContracts(enigmaContractAddr, tokenContractAddr) Initialize the Enigma and Enigma token contracts Kind : global function | Param | Type | | --- | --- | | enigmaContractAddr | string | | tokenContractAddr | string | createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task Create a base Task - a wrapper for a task (either contract deployments or regular tasks) Kind : global function Returns : Task - Task with base attributes to be used for remainder of task lifecycle | Param | Type | Description | | --- | --- | --- | | fn | string | Function name | | args | Array | Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] | | gasLimit | Number | ENG gas limit for task computation | | gasPx | Number | ENG gas price for task computation | | sender | string | ETH address for task sender | | scAddrOrPreCode | string | Either secret contract address or precode, depending on if user is running a contract deployment or regular task | | isContractDeploymentTask | boolean | Is this task a contract deployment task (if not, it's a regular task) | createTaskRecord(task) \u21d2 EventEmitter Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task record. Emits a Task with task record creation attributes to be used for remainder of task lifecycle | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | createTaskRecords(tasks) \u21d2 EventEmitter Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task records. Emits Tasks with task record creation attributes to be used for remainder of task lifecycle | Param | Type | Description | | --- | --- | --- | | tasks | Array | Task wrappers for contract deployment and regular tasks | getTaskRecordStatus(task) \u21d2 Promise Get the Task's task record status from Ethereum Kind : global function Returns : Promise - Resolves to Task wrapper with updated ethStatus and proof properties | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | getReport(custodian) \u21d2 Promise Find SGX report Kind : global function Returns : Promise - Resolves to SGX report for the worker | Param | Type | Description | | --- | --- | --- | | custodian | string | Worker's address | getWorkerParams(blockNumber) \u21d2 Promise Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. Kind : global function Returns : Promise - Resolves to the worker params, which includes a seed (random int generated from the principal node), first block number for the epoch, list of active work addresses (ordered list of workers that were logged in at the start of the epoch), and list of active worker balances | Param | Type | Description | | --- | --- | --- | | blockNumber | int | Block number of task record's mining | selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array Select the workers weighted-randomly based on the staked token amount that will run the computation task Kind : global function Returns : Array - An array of selected workers where each selected worker is chosen with probability equal to number of staked tokens | Param | Type | Default | Description | | --- | --- | --- | --- | | scAddr | string | | Secret contract address | | params | Object | | Worker params | | workerGroupSize | number | 5 | Number of workers to be selected for task | sendTaskInput(task) \u21d2 EventEmitter Send Task to Enigma p2p network for computation Kind : global function Returns : EventEmitter - EventEmitter to be listened to track submission of Task to Enigma p2p network. Emits a response from the ENG network indicating whether client is ready to track the remainder of the task lifecycle | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | getTaskResult(task) \u21d2 EventEmitter Get task result from p2p network Kind : global function Returns : EventEmitter - EventEmitter to be listened to track getting result from Enigma network. Emits a response from the ENG network. | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | pollTaskStatusGen(task, withResult) Generator function for polling the Enigma p2p network for task status Kind : global function | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | | withResult | boolean | Task wrapper for contract deployment and regular tasks | innerPollTaskStatus(task, generator, emitter) Inner poll status function that continues to poll the Enigma p2p network until the task has been verified Kind : global function | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | | generator | pollTaskStatusGen | Generator function for polling Enigma p2p network for task status | | emitter | EventEmitter | EventEmitter to track Enigma p2p network polling for Task status | pollTaskStatus(task, withResult) \u21d2 EventEmitter Poll the Enigma p2p network for a TaskInput's status Kind : global function Returns : EventEmitter - EventEmitter to be listened to track polling the Enigma p2p network for a Task status. Emits a Task with task result attributes | Param | Type | Default | Description | | --- | --- | --- | --- | | task | Task | | Task wrapper for contract deployment and regular tasks | | withResult | boolean | false | Task wrapper for contract deployment and regular tasks | serializeTask(task) \u21d2 Object Serialize Task for submission to the Enigma p2p network Kind : global function Returns : Object - Serialized Task for submission to the Enigma p2p network | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | obtainTaskKeyPair() \u21d2 Object Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. Kind : global function Returns : Object - Public key-private key pair deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network | Param | Type | Description | | --- | --- | --- | | fn | string | Function name | | args | Array | Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] | | gasLimit | Number | ENG gas limit for task computation | | gasPx | Number | ENG gas price for task computation | | sender | string | ETH address for task sender | | preCode | string | Precode for contract deployment | computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task Create a compute task - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network | Param | Type | Description | | --- | --- | --- | | fn | string | Function name | | args | Array | Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] | | gasLimit | Number | ENG gas limit for task computation | | gasPx | Number | ENG gas price for task computation | | sender | string | ETH address for task sender | | scAddr | string | Secret contract address | version() \u21d2 string Return the version number of the library Kind : global function Ainsleys-MacBook-Pro:api ainsleyenigma$","title":"API"},{"location":"API/#functions","text":"admin() Initialize the worker-specific admin features createContracts(enigmaContractAddr, tokenContractAddr) Initialize the Enigma and Enigma token contracts createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task Create a base Task - a wrapper for a task (either contract deployments or regular tasks) createTaskRecord(task) \u21d2 EventEmitter Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. createTaskRecords(tasks) \u21d2 EventEmitter Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user s public key), user s nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. getTaskRecordStatus(task) \u21d2 Promise Get the Task s task record status from Ethereum getReport(custodian) \u21d2 Promise Find SGX report getWorkerParams(blockNumber) \u21d2 Promise Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array Select the workers weighted-randomly based on the staked token amount that will run the computation task sendTaskInput(task) \u21d2 EventEmitter Send Task to Enigma p2p network for computation getTaskResult(task) \u21d2 EventEmitter Get task result from p2p network pollTaskStatusGen(task, withResult) Generator function for polling the Enigma p2p network for task status innerPollTaskStatus(task, generator, emitter) Inner poll status function that continues to poll the Enigma p2p network until the task has been verified pollTaskStatus(task, withResult) \u21d2 EventEmitter Poll the Enigma p2p network for a TaskInput s status serializeTask(task) \u21d2 Object Serialize Task for submission to the Enigma p2p network obtainTaskKeyPair() \u21d2 Object Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task Create a compute task - creates base task, creates task record, and sends task to the Enigma network. version() \u21d2 string Return the version number of the library","title":"Functions"},{"location":"API/#admin","text":"Initialize the worker-specific admin features Kind : global function","title":"admin()"},{"location":"API/#createcontractsenigmacontractaddr-tokencontractaddr","text":"Initialize the Enigma and Enigma token contracts Kind : global function | Param | Type | | --- | --- | | enigmaContractAddr | string | | tokenContractAddr | string |","title":"createContracts(enigmaContractAddr, tokenContractAddr)"},{"location":"API/#createtaskfn-args-gaslimit-gaspx-sender-scaddrorprecode-iscontractdeploymenttask-task","text":"Create a base Task - a wrapper for a task (either contract deployments or regular tasks) Kind : global function Returns : Task - Task with base attributes to be used for remainder of task lifecycle | Param | Type | Description | | --- | --- | --- | | fn | string | Function name | | args | Array | Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] | | gasLimit | Number | ENG gas limit for task computation | | gasPx | Number | ENG gas price for task computation | | sender | string | ETH address for task sender | | scAddrOrPreCode | string | Either secret contract address or precode, depending on if user is running a contract deployment or regular task | | isContractDeploymentTask | boolean | Is this task a contract deployment task (if not, it's a regular task) |","title":"createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) \u21d2 Task"},{"location":"API/#createtaskrecordtask-eventemitter","text":"Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task record. Emits a Task with task record creation attributes to be used for remainder of task lifecycle | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks |","title":"createTaskRecord(task) \u21d2 EventEmitter"},{"location":"API/#createtaskrecordstasks-eventemitter","text":"Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee and computing the immutable taskId (a unique value for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit, gas price, user's public key), user's nonce value monotonically increasing for every task deployment). Thus, task records have important implications for task ordering, fee payments, and verification. Kind : global function Returns : EventEmitter - EventEmitter to be listened to track creation of task records. Emits Tasks with task record creation attributes to be used for remainder of task lifecycle | Param | Type | Description | | --- | --- | --- | | tasks | Array | Task wrappers for contract deployment and regular tasks |","title":"createTaskRecords(tasks) \u21d2 EventEmitter"},{"location":"API/#gettaskrecordstatustask-promise","text":"Get the Task's task record status from Ethereum Kind : global function Returns : Promise - Resolves to Task wrapper with updated ethStatus and proof properties | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks |","title":"getTaskRecordStatus(task) \u21d2 Promise"},{"location":"API/#getreportcustodian-promise","text":"Find SGX report Kind : global function Returns : Promise - Resolves to SGX report for the worker | Param | Type | Description | | --- | --- | --- | | custodian | string | Worker's address |","title":"getReport(custodian) \u21d2 Promise"},{"location":"API/#getworkerparamsblocknumber-promise","text":"Given a block number, obtain the worker parameters. These parameters remain the same for a given secret contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes. Kind : global function Returns : Promise - Resolves to the worker params, which includes a seed (random int generated from the principal node), first block number for the epoch, list of active work addresses (ordered list of workers that were logged in at the start of the epoch), and list of active worker balances | Param | Type | Description | | --- | --- | --- | | blockNumber | int | Block number of task record's mining |","title":"getWorkerParams(blockNumber) \u21d2 Promise"},{"location":"API/#selectworkergroupscaddr-params-workergroupsize-array","text":"Select the workers weighted-randomly based on the staked token amount that will run the computation task Kind : global function Returns : Array - An array of selected workers where each selected worker is chosen with probability equal to number of staked tokens | Param | Type | Default | Description | | --- | --- | --- | --- | | scAddr | string | | Secret contract address | | params | Object | | Worker params | | workerGroupSize | number | 5 | Number of workers to be selected for task |","title":"selectWorkerGroup(scAddr, params, workerGroupSize) \u21d2 Array"},{"location":"API/#sendtaskinputtask-eventemitter","text":"Send Task to Enigma p2p network for computation Kind : global function Returns : EventEmitter - EventEmitter to be listened to track submission of Task to Enigma p2p network. Emits a response from the ENG network indicating whether client is ready to track the remainder of the task lifecycle | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks |","title":"sendTaskInput(task) \u21d2 EventEmitter"},{"location":"API/#gettaskresulttask-eventemitter","text":"Get task result from p2p network Kind : global function Returns : EventEmitter - EventEmitter to be listened to track getting result from Enigma network. Emits a response from the ENG network. | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks |","title":"getTaskResult(task) \u21d2 EventEmitter"},{"location":"API/#polltaskstatusgentask-withresult","text":"Generator function for polling the Enigma p2p network for task status Kind : global function | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | | withResult | boolean | Task wrapper for contract deployment and regular tasks |","title":"pollTaskStatusGen(task, withResult)"},{"location":"API/#innerpolltaskstatustask-generator-emitter","text":"Inner poll status function that continues to poll the Enigma p2p network until the task has been verified Kind : global function | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks | | generator | pollTaskStatusGen | Generator function for polling Enigma p2p network for task status | | emitter | EventEmitter | EventEmitter to track Enigma p2p network polling for Task status |","title":"innerPollTaskStatus(task, generator, emitter)"},{"location":"API/#polltaskstatustask-withresult-eventemitter","text":"Poll the Enigma p2p network for a TaskInput's status Kind : global function Returns : EventEmitter - EventEmitter to be listened to track polling the Enigma p2p network for a Task status. Emits a Task with task result attributes | Param | Type | Default | Description | | --- | --- | --- | --- | | task | Task | | Task wrapper for contract deployment and regular tasks | | withResult | boolean | false | Task wrapper for contract deployment and regular tasks |","title":"pollTaskStatus(task, withResult) \u21d2 EventEmitter"},{"location":"API/#serializetasktask-object","text":"Serialize Task for submission to the Enigma p2p network Kind : global function Returns : Object - Serialized Task for submission to the Enigma p2p network | Param | Type | Description | | --- | --- | --- | | task | Task | Task wrapper for contract deployment and regular tasks |","title":"serializeTask(task) \u21d2 Object"},{"location":"API/#obtaintaskkeypair-object","text":"Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected worker. This pair will be stored in local storage for quick retrieval. Kind : global function Returns : Object - Public key-private key pair","title":"obtainTaskKeyPair() \u21d2 Object"},{"location":"API/#deploysecretcontractfn-args-gaslimit-gaspx-sender-precode-task","text":"Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network | Param | Type | Description | | --- | --- | --- | | fn | string | Function name | | args | Array | Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] | | gasLimit | Number | ENG gas limit for task computation | | gasPx | Number | ENG gas price for task computation | | sender | string | ETH address for task sender | | preCode | string | Precode for contract deployment |","title":"deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) \u21d2 Task"},{"location":"API/#computetaskfn-args-gaslimit-gaspx-sender-scaddr-task","text":"Create a compute task - creates base task, creates task record, and sends task to the Enigma network. Kind : global function Returns : Task - Task with attributes necessary for task record and Enigma network | Param | Type | Description | | --- | --- | --- | | fn | string | Function name | | args | Array | Inputs for task in the form of [[arg1, ' '], ..., [argn, ' ']] | | gasLimit | Number | ENG gas limit for task computation | | gasPx | Number | ENG gas price for task computation | | sender | string | ETH address for task sender | | scAddr | string | Secret contract address |","title":"computeTask(fn, args, gasLimit, gasPx, sender, scAddr) \u21d2 Task"},{"location":"API/#version-string","text":"Return the version number of the library Kind : global function Ainsleys-MacBook-Pro:api ainsleyenigma$","title":"version() \u21d2 string"},{"location":"ApplicationDesign/","text":"Building With Secrets \ud83d\udd10 This section introduces several concepts we think are useful when working with secret contracts and the Enigma network. \ud83e\udd1eWe also highly recommend our developer forum for application-specific design questions. This section covers actions you may want to take such as: Reading Ethereum State Getting data from oracles Working with Metamask and managing user credentials Design Patterns for Secret Contracts like: a. Relayers b. Timekeeping Reading Ethereum State Getting data from oracles Metamask and Web3 Design Patterns for Secret Contracts","title":"Building With Secrets \ud83d\udd10"},{"location":"ApplicationDesign/#building-with-secrets","text":"This section introduces several concepts we think are useful when working with secret contracts and the Enigma network. \ud83e\udd1eWe also highly recommend our developer forum for application-specific design questions. This section covers actions you may want to take such as: Reading Ethereum State Getting data from oracles Working with Metamask and managing user credentials Design Patterns for Secret Contracts like: a. Relayers b. Timekeeping","title":"Building With Secrets \ud83d\udd10"},{"location":"ApplicationDesign/#reading-ethereum-state","text":"","title":"Reading Ethereum State"},{"location":"ApplicationDesign/#getting-data-from-oracles","text":"","title":"Getting data from oracles"},{"location":"ApplicationDesign/#metamask-and-web3","text":"","title":"Metamask and Web3"},{"location":"ApplicationDesign/#design-patterns-for-secret-contracts","text":"","title":"Design Patterns for Secret Contracts"},{"location":"DeploymentWalkthrough/","text":"Building the dApp \ud83c\udfac Adi's Enigma JS Library, deployment walkthrough","title":"Building the dApp \ud83c\udfac"},{"location":"DeploymentWalkthrough/#building-the-dapp","text":"Adi's Enigma JS Library, deployment walkthrough","title":"Building the dApp \ud83c\udfac"},{"location":"DeveloperMode/","text":"Developer Mode \ud83d\udcbb Developer mode (also known as Simulation mode) enables local deployment and testing of the Enigma Network as a series of Docker containers. This is the development mode we recommend for application developers writing secret contracts. While it is possible to deploy the network in \"hardware mode\", we recommend this for node runners.","title":"Developer Mode \ud83d\udcbb"},{"location":"DeveloperMode/#developer-mode","text":"Developer mode (also known as Simulation mode) enables local deployment and testing of the Enigma Network as a series of Docker containers. This is the development mode we recommend for application developers writing secret contracts. While it is possible to deploy the network in \"hardware mode\", we recommend this for node runners.","title":"Developer Mode \ud83d\udcbb"},{"location":"DiscoveryTestnet/","text":"Connecting to Discovery on Testnet \ud83c\udfd7\ufe0f Coming soon! \ud83d\udc77\u200d\u2640\ufe0f","title":"Connecting to Discovery on Testnet \ud83c\udfd7\ufe0f"},{"location":"DiscoveryTestnet/#connecting-to-discovery-on-testnet","text":"Coming soon! \ud83d\udc77\u200d\u2640\ufe0f","title":"Connecting to Discovery on Testnet \ud83c\udfd7\ufe0f"},{"location":"EnigmaArchitecture/","text":"Enigma Network Architecture \ud83e\udd1d Enigma and Ethereum work together, and separate computation and storage from consensus. Enigma: Compute and Storage Layer Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys. Ethereum: Consensus Layer Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status.","title":"Enigma Network Architecture \ud83e\udd1d"},{"location":"EnigmaArchitecture/#enigma-network-architecture","text":"Enigma and Ethereum work together, and separate computation and storage from consensus.","title":"Enigma Network Architecture \ud83e\udd1d"},{"location":"EnigmaArchitecture/#enigma-compute-and-storage-layer","text":"Secret Contract Engine : Executes computations. Peer-to-peer Network : Propagates messages in the Enigma network. State Management : Stores and manages the state. Key Management : Stores and manages encryption, decryption and signing keys.","title":"Enigma: Compute and Storage Layer"},{"location":"EnigmaArchitecture/#ethereum-consensus-layer","text":"Shared Ledger : Stores the worker registry, task records and proofs of completed tasks. Consensus : Agreement on task order and confirmation status.","title":"Ethereum: Consensus Layer"},{"location":"EnigmaOverview/","text":"An Overview of Enigma \ud83d\udd0d The Enigma Network offloads private computation tasks from Ethereum. These tasks are initiated by the end users of Ethereum dApps. The Enigma protocol provides Enigma-JS, a JavaScript library that gives dApp developers the tools to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. A key distinction between the current Discovery release and the last release is that the Enigma Network has its own secret contracts. Instead of writing the business logic of a computation task in a function of an Ethereum smart contract, the dApp author creates a secret contract and deploys it on the Enigma Network. This is more powerful for many reasons; notably, a secret contract may store an encrypted state. The Enigma Library Computation tasks are created by dApp users using the Enigma Library. In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks. On-Chain Computation Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas. Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results. A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Unlike MVT, workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: 1. the current epoch ends 2. the business logic of a task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. Ethereum does not store the tasks results nor the encrypted state deltas, only hashes from which nodes can verify the integrity of their own data.","title":"Enigma Technical Overview"},{"location":"EnigmaOverview/#an-overview-of-enigma","text":"The Enigma Network offloads private computation tasks from Ethereum. These tasks are initiated by the end users of Ethereum dApps. The Enigma protocol provides Enigma-JS, a JavaScript library that gives dApp developers the tools to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. A key distinction between the current Discovery release and the last release is that the Enigma Network has its own secret contracts. Instead of writing the business logic of a computation task in a function of an Ethereum smart contract, the dApp author creates a secret contract and deploys it on the Enigma Network. This is more powerful for many reasons; notably, a secret contract may store an encrypted state.","title":"An Overview of Enigma \ud83d\udd0d"},{"location":"EnigmaOverview/#the-enigma-library","text":"Computation tasks are created by dApp users using the Enigma Library. In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks.","title":"The Enigma Library"},{"location":"EnigmaOverview/#on-chain-computation","text":"Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas. Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results. A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Unlike MVT, workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: 1. the current epoch ends 2. the business logic of a task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. Ethereum does not store the tasks results nor the encrypted state deltas, only hashes from which nodes can verify the integrity of their own data.","title":"On-Chain Computation"},{"location":"FAQ/","text":"Discovery FAQ Data What is the size limit for data input to a secret computation? Currently, the size limit is 1 MB. We expect this number to be larger very soon. Does encrypted data have to be passed through an Ethereum contract before it can be computed on? The Discovery release uses \"Task Records\" to track computation tasks on Ethereum. A Task Record is a hash of all the inputs to a secret contract. It takes up significantly less space than raw data would. These hashed Task Records are submitted to Ethereum at the same time as the encrypted Task data is submitted to Enigma. Can encrypted data be stored on the Enigma network? Yes, Secret Contracts are stateful in the Discovery release. Nodes How does Enigma protect against side-channel attacks like Foreshadow and Spectre? This is a class of attack deployed against Trusted Execution Environments. In addition to Intel's protections against these attacks, Enigma provides the following features: Randomly selected nodes: A worker is never guaranteed to be selected for a task, increasing the cost and decreasing the potential value of executing a side-channel attack. Enigma Attestation Process: Enigma has streamlined a version of the Intel Attestation service for nodes. Local consensus: nodes agree on the result of a computation, ensuring that a worker is not returning an incorrect result. (NOTE: this is not part of the initial Discovery Developer Release) How is data shared between nodes? Ethereum Will the Discovery release be on a public Ethereum testnet i.e., Rinkeby/Ropsten/Kovan? Yes, we will launch Discovery on a public testnet prior to mainnet launch. However, the developer testnet release is only deployed locally. Will we be able to swap tokens for ENG easily to facilitate payment? Supporting token abstraction is a high-priority goal, but is not included in the Discovery developer release. Secret Contracts Will Discovery contracts be forward-compatible Yes. Future iterations of the network will also support Rust-based contracts, and we are aiming for forward compatibility in all contracts. What languages are supported for secret contracts? Secret contracts are written using Rust. Oracles How do I get oracle data into a computation? We currently do not support TLS or HTTP requests within a computation. We suggest that developers utilize a relayer model where applicable to obtain and submit this type of data.","title":"FAQ"},{"location":"FAQ/#discovery-faq","text":"","title":"Discovery FAQ"},{"location":"FAQ/#data","text":"","title":"Data"},{"location":"FAQ/#what-is-the-size-limit-for-data-input-to-a-secret-computation","text":"Currently, the size limit is 1 MB. We expect this number to be larger very soon.","title":"What is the size limit for data input to a secret computation?"},{"location":"FAQ/#does-encrypted-data-have-to-be-passed-through-an-ethereum-contract-before-it-can-be-computed-on","text":"The Discovery release uses \"Task Records\" to track computation tasks on Ethereum. A Task Record is a hash of all the inputs to a secret contract. It takes up significantly less space than raw data would. These hashed Task Records are submitted to Ethereum at the same time as the encrypted Task data is submitted to Enigma.","title":"Does encrypted data have to be passed through an Ethereum contract before it can be computed on?"},{"location":"FAQ/#can-encrypted-data-be-stored-on-the-enigma-network","text":"Yes, Secret Contracts are stateful in the Discovery release.","title":"Can encrypted data be stored on the Enigma network?"},{"location":"FAQ/#nodes","text":"","title":"Nodes"},{"location":"FAQ/#how-does-enigma-protect-against-side-channel-attacks-like-foreshadow-and-spectre","text":"This is a class of attack deployed against Trusted Execution Environments. In addition to Intel's protections against these attacks, Enigma provides the following features: Randomly selected nodes: A worker is never guaranteed to be selected for a task, increasing the cost and decreasing the potential value of executing a side-channel attack. Enigma Attestation Process: Enigma has streamlined a version of the Intel Attestation service for nodes. Local consensus: nodes agree on the result of a computation, ensuring that a worker is not returning an incorrect result. (NOTE: this is not part of the initial Discovery Developer Release)","title":"How does Enigma protect against side-channel attacks like Foreshadow and Spectre?"},{"location":"FAQ/#how-is-data-shared-between-nodes","text":"","title":"How is data shared between nodes?"},{"location":"FAQ/#ethereum","text":"","title":"Ethereum"},{"location":"FAQ/#will-the-discovery-release-be-on-a-public-ethereum-testnet-ie-rinkebyropstenkovan","text":"Yes, we will launch Discovery on a public testnet prior to mainnet launch. However, the developer testnet release is only deployed locally.","title":"Will the Discovery release be on a public Ethereum testnet i.e., Rinkeby/Ropsten/Kovan?"},{"location":"FAQ/#will-we-be-able-to-swap-tokens-for-eng-easily-to-facilitate-payment","text":"Supporting token abstraction is a high-priority goal, but is not included in the Discovery developer release.","title":"Will we be able to swap tokens for ENG easily to facilitate payment?"},{"location":"FAQ/#secret-contracts","text":"","title":"Secret Contracts"},{"location":"FAQ/#will-discovery-contracts-be-forward-compatible","text":"Yes. Future iterations of the network will also support Rust-based contracts, and we are aiming for forward compatibility in all contracts.","title":"Will Discovery contracts be forward-compatible"},{"location":"FAQ/#what-languages-are-supported-for-secret-contracts","text":"Secret contracts are written using Rust.","title":"What languages are supported for secret contracts?"},{"location":"FAQ/#oracles","text":"","title":"Oracles"},{"location":"FAQ/#how-do-i-get-oracle-data-into-a-computation","text":"We currently do not support TLS or HTTP requests within a computation. We suggest that developers utilize a relayer model where applicable to obtain and submit this type of data.","title":"How do I get oracle data into a computation?"},{"location":"Fees/","text":"Computation Fees \ud83c\udfc6 Secret Contracts are executed by nodes in the Enigma Network. Nodes are incentivized to perform these computations with fees paid by the user initiating the computation.","title":"Computation Fees \ud83c\udfc6"},{"location":"Fees/#computation-fees","text":"Secret Contracts are executed by nodes in the Enigma Network. Nodes are incentivized to perform these computations with fees paid by the user initiating the computation.","title":"Computation Fees \ud83c\udfc6"},{"location":"GettingStarted/","text":"Check the documentation for how to use Docusaurus. Lorem Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus elementum massa eget nulla aliquet sagittis. Proin odio tortor, vulputate ut odio in, ultrices ultricies augue. Cras ornare ultrices lorem malesuada iaculis. Etiam sit amet libero tempor, pulvinar mauris sed, sollicitudin sapien. Mauris In Code Mauris vestibulum ullamcorper nibh, ut semper purus pulvinar ut. Donec volutpat orci sit amet mauris malesuada, non pulvinar augue aliquam. Vestibulum ultricies at urna ut suscipit. Morbi iaculis, erat at imperdiet semper, ipsum nulla sodales erat, eget tincidunt justo dui quis justo. Pellentesque dictum bibendum diam at aliquet. Sed pulvinar, dolor quis finibus ornare, eros odio facilisis erat, eu rhoncus nunc dui sed ex. Nunc gravida dui massa, sed ornare arcu tincidunt sit amet. Maecenas efficitur sapien neque, a laoreet libero feugiat ut. Nulla Nulla facilisi. Maecenas sodales nec purus eget posuere. Sed sapien quam, pretium a risus in, porttitor dapibus erat. Sed sit amet fringilla ipsum, eget iaculis augue. Integer sollicitudin tortor quis ultricies aliquam. Suspendisse fringilla nunc in tellus cursus, at placerat tellus scelerisque. Sed tempus elit a sollicitudin rhoncus. Nulla facilisi. Morbi nec dolor dolor. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Cras et aliquet lectus. Pellentesque sit amet eros nisi. Quisque ac sapien in sapien congue accumsan. Nullam in posuere ante. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Proin lacinia leo a nibh fringilla pharetra. Orci Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Proin venenatis lectus dui, vel ultrices ante bibendum hendrerit. Aenean egestas feugiat dui id hendrerit. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur in tellus laoreet, eleifend nunc id, viverra leo. Proin vulputate non dolor vel vulputate. Curabitur pretium lobortis felis, sit amet finibus lorem suscipit ut. Sed non mollis risus. Duis sagittis, mi in euismod tincidunt, nunc mauris vestibulum urna, at euismod est elit quis erat. Phasellus accumsan vitae neque eu placerat. In elementum arcu nec tellus imperdiet, eget maximus nulla sodales. Curabitur eu sapien eget nisl sodales fermentum. Phasellus Phasellus pulvinar ex id commodo imperdiet. Praesent odio nibh, sollicitudin sit amet faucibus id, placerat at metus. Donec vitae eros vitae tortor hendrerit finibus. Interdum et malesuada fames ac ante ipsum primis in faucibus. Quisque vitae purus dolor. Duis suscipit ac nulla et finibus. Phasellus ac sem sed dui dictum gravida. Phasellus eleifend vestibulum facilisis. Integer pharetra nec enim vitae mattis. Duis auctor, lectus quis condimentum bibendum, nunc dolor aliquam massa, id bibendum orci velit quis magna. Ut volutpat nulla nunc, sed interdum magna condimentum non. Sed urna metus, scelerisque vitae consectetur a, feugiat quis magna. Donec dignissim ornare nisl, eget tempor risus malesuada quis.","title":"Getting Started"},{"location":"GettingStarted/#lorem","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus elementum massa eget nulla aliquet sagittis. Proin odio tortor, vulputate ut odio in, ultrices ultricies augue. Cras ornare ultrices lorem malesuada iaculis. Etiam sit amet libero tempor, pulvinar mauris sed, sollicitudin sapien.","title":"Lorem"},{"location":"GettingStarted/#mauris-in-code","text":"Mauris vestibulum ullamcorper nibh, ut semper purus pulvinar ut. Donec volutpat orci sit amet mauris malesuada, non pulvinar augue aliquam. Vestibulum ultricies at urna ut suscipit. Morbi iaculis, erat at imperdiet semper, ipsum nulla sodales erat, eget tincidunt justo dui quis justo. Pellentesque dictum bibendum diam at aliquet. Sed pulvinar, dolor quis finibus ornare, eros odio facilisis erat, eu rhoncus nunc dui sed ex. Nunc gravida dui massa, sed ornare arcu tincidunt sit amet. Maecenas efficitur sapien neque, a laoreet libero feugiat ut.","title":"Mauris In Code"},{"location":"GettingStarted/#nulla","text":"Nulla facilisi. Maecenas sodales nec purus eget posuere. Sed sapien quam, pretium a risus in, porttitor dapibus erat. Sed sit amet fringilla ipsum, eget iaculis augue. Integer sollicitudin tortor quis ultricies aliquam. Suspendisse fringilla nunc in tellus cursus, at placerat tellus scelerisque. Sed tempus elit a sollicitudin rhoncus. Nulla facilisi. Morbi nec dolor dolor. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Cras et aliquet lectus. Pellentesque sit amet eros nisi. Quisque ac sapien in sapien congue accumsan. Nullam in posuere ante. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Proin lacinia leo a nibh fringilla pharetra.","title":"Nulla"},{"location":"GettingStarted/#orci","text":"Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Proin venenatis lectus dui, vel ultrices ante bibendum hendrerit. Aenean egestas feugiat dui id hendrerit. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Curabitur in tellus laoreet, eleifend nunc id, viverra leo. Proin vulputate non dolor vel vulputate. Curabitur pretium lobortis felis, sit amet finibus lorem suscipit ut. Sed non mollis risus. Duis sagittis, mi in euismod tincidunt, nunc mauris vestibulum urna, at euismod est elit quis erat. Phasellus accumsan vitae neque eu placerat. In elementum arcu nec tellus imperdiet, eget maximus nulla sodales. Curabitur eu sapien eget nisl sodales fermentum.","title":"Orci"},{"location":"GettingStarted/#phasellus","text":"Phasellus pulvinar ex id commodo imperdiet. Praesent odio nibh, sollicitudin sit amet faucibus id, placerat at metus. Donec vitae eros vitae tortor hendrerit finibus. Interdum et malesuada fames ac ante ipsum primis in faucibus. Quisque vitae purus dolor. Duis suscipit ac nulla et finibus. Phasellus ac sem sed dui dictum gravida. Phasellus eleifend vestibulum facilisis. Integer pharetra nec enim vitae mattis. Duis auctor, lectus quis condimentum bibendum, nunc dolor aliquam massa, id bibendum orci velit quis magna. Ut volutpat nulla nunc, sed interdum magna condimentum non. Sed urna metus, scelerisque vitae consectetur a, feugiat quis magna. Donec dignissim ornare nisl, eget tempor risus malesuada quis.","title":"Phasellus"},{"location":"Glossary/","text":"Glossary Attestation A process by which a piece of software can prove that is running in a secure container ( enclave ) on trusted hardware. This proof is a cryptographic signature, that certifies the hash of the secure container\u2019s contents. Attestation can be local , if two enclaves communicate with each other on the same host, or remote if it is attesting to a remote entity that it is trusted, and thus establishing an authenticated communication channel with that entity. Batch A set of tasks within an epoch that do not modify the state in the Ethereum network. dApp User An end=user of the Enigma network, responsible for initiating a task on the network. These users must: Have an Ethereum account Interface with the Enigma network through the Enigma JS Library Enclave An enclave is a private region of memory protected from processes running at higher privilege levels. Enclaves are only found in specific hardware that implements Trusted Execution Environments (TEE), like Intel Software Guard Extensions (SGX). An enclave is a critical component of a worker node. Any Secret Node must meet these hardware requirements. Epoch A unit of time in the Enigma network in which a worker node is assigned to work on a set of secret contracts does not change, and in which the state encryption keys do not change. Guarded (Code): Code that runs inside an enclave , that is code that executes with privacy and correctness guarantees. Guarded code typically has an unguarded counterpart. MVT Minimum Viable Testnet: The initial release of the Enigma protocol released on June 30th, 2018 as a dockerized network. It provided a sandbox environment aimed at developers of secret contracts to get started with the Enigma Protocol. Refer to the announcement of the release. Secret Contract Secret contracts are smart contracts that provide confidentiality guarantees. The contract functions are executed over encrypted inputs and outputs. Whereas smart contracts are defined as self-executing contracts with the terms of the agreement between parties being directly written into lines of code , secret contracts add privacy to the data submitted to these contracts. While the code of secret contracts remains public and auditable, the inputs and outputs to the contract are encrypted and hidden from public view. Secret contracts thus provide data privacy and verifiable computation. Secret contracts exist across a distributed, decentralized blockchain network ( Enigma ) and permit trusted and privacy-preserving transactions and agreements to be carried out among disparate, anonymous parties without the need for a central authority, legal system, or external enforcement mechanism. Task A single computation, also defined as a secret contract function call. Task Receipt A publicly verifiable proof that a task has been computed by an uncompromised enclave with all intended inputs. Task Record The record of a task stored on the Ethereum network for the purposes of: Ordering Fee Payment Token deposits (for payable functions) Unguarded (Code): Code that executes outside of an enclave , providing an interface between the code that runs inside the enclave ( guarded ) and the outside world. Unguarded code does not provide neither correctness nor privacy guarantees. User Node Node from the Enigma network through which a dApp user interfaces with the network. The user node brokers data flows between the dApp user, the worker node and other network participants using the peer-to-peer network protocol. dApp users can freely choose their user nodes through which they interact with the network. It may happen that the user node becomes the worker node for a given taks, but only if it happened to be randomly selected by the network. Worker or Worker Node Secret Node of the Enigma network selected to execute a task inside an enclave , characterized as follows: A task is only assigned one worker insofar as the worker meets the task\u2019s service level agreement A contract is only assigned one worker per epoch insofar as the worker successfully executes the tasks assigned.","title":"Glossary"},{"location":"Glossary/#glossary","text":"","title":"Glossary"},{"location":"Glossary/#attestation","text":"A process by which a piece of software can prove that is running in a secure container ( enclave ) on trusted hardware. This proof is a cryptographic signature, that certifies the hash of the secure container\u2019s contents. Attestation can be local , if two enclaves communicate with each other on the same host, or remote if it is attesting to a remote entity that it is trusted, and thus establishing an authenticated communication channel with that entity.","title":"Attestation"},{"location":"Glossary/#batch","text":"A set of tasks within an epoch that do not modify the state in the Ethereum network.","title":"Batch"},{"location":"Glossary/#dapp-user","text":"An end=user of the Enigma network, responsible for initiating a task on the network. These users must: Have an Ethereum account Interface with the Enigma network through the Enigma JS Library","title":"dApp User"},{"location":"Glossary/#enclave","text":"An enclave is a private region of memory protected from processes running at higher privilege levels. Enclaves are only found in specific hardware that implements Trusted Execution Environments (TEE), like Intel Software Guard Extensions (SGX). An enclave is a critical component of a worker node. Any Secret Node must meet these hardware requirements.","title":"Enclave"},{"location":"Glossary/#epoch","text":"A unit of time in the Enigma network in which a worker node is assigned to work on a set of secret contracts does not change, and in which the state encryption keys do not change.","title":"Epoch"},{"location":"Glossary/#guarded-code","text":"Code that runs inside an enclave , that is code that executes with privacy and correctness guarantees. Guarded code typically has an unguarded counterpart.","title":"Guarded (Code):"},{"location":"Glossary/#mvt","text":"Minimum Viable Testnet: The initial release of the Enigma protocol released on June 30th, 2018 as a dockerized network. It provided a sandbox environment aimed at developers of secret contracts to get started with the Enigma Protocol. Refer to the announcement of the release.","title":"MVT"},{"location":"Glossary/#secret-contract","text":"Secret contracts are smart contracts that provide confidentiality guarantees. The contract functions are executed over encrypted inputs and outputs. Whereas smart contracts are defined as self-executing contracts with the terms of the agreement between parties being directly written into lines of code , secret contracts add privacy to the data submitted to these contracts. While the code of secret contracts remains public and auditable, the inputs and outputs to the contract are encrypted and hidden from public view. Secret contracts thus provide data privacy and verifiable computation. Secret contracts exist across a distributed, decentralized blockchain network ( Enigma ) and permit trusted and privacy-preserving transactions and agreements to be carried out among disparate, anonymous parties without the need for a central authority, legal system, or external enforcement mechanism.","title":"Secret Contract"},{"location":"Glossary/#task","text":"A single computation, also defined as a secret contract function call.","title":"Task"},{"location":"Glossary/#task-receipt","text":"A publicly verifiable proof that a task has been computed by an uncompromised enclave with all intended inputs.","title":"Task Receipt"},{"location":"Glossary/#task-record","text":"The record of a task stored on the Ethereum network for the purposes of: Ordering Fee Payment Token deposits (for payable functions)","title":"Task Record"},{"location":"Glossary/#unguarded-code","text":"Code that executes outside of an enclave , providing an interface between the code that runs inside the enclave ( guarded ) and the outside world. Unguarded code does not provide neither correctness nor privacy guarantees.","title":"Unguarded (Code):"},{"location":"Glossary/#user-node","text":"Node from the Enigma network through which a dApp user interfaces with the network. The user node brokers data flows between the dApp user, the worker node and other network participants using the peer-to-peer network protocol. dApp users can freely choose their user nodes through which they interact with the network. It may happen that the user node becomes the worker node for a given taks, but only if it happened to be randomly selected by the network.","title":"User Node"},{"location":"Glossary/#worker-or-worker-node","text":"Secret Node of the Enigma network selected to execute a task inside an enclave , characterized as follows: A task is only assigned one worker insofar as the worker meets the task\u2019s service level agreement A contract is only assigned one worker per epoch insofar as the worker successfully executes the tasks assigned.","title":"Worker or Worker Node"},{"location":"IntroductionToDeployment/","text":"Deploying the Enigma Network \ud83d\udce1 Discovery can currently be deployed in two ways: Developer Mode : a series of containers in a Docker environment. This is also known as \"Simulation Mode\" because it does not require you to have hardware SGX support (meaning yes, you can develop on your macbook!). Hardware Mode : This mode requires hardware-level compatibility (see \"System Requirements\"). This is useful for users who may want to run Secret Nodes. For a step-by-step walkthrough of the \"developer mode\" deployment process, see our Getting Started guide. \ud83e\udd1eDiscovery will be also soon deployed to a public Ethereum testnet, giving you the opportunity to test your applications in the wild on a network of nodes, and streamlining your development options. Stay tuned! \ud83d\udcfa","title":"Deploy Discovery"},{"location":"IntroductionToDeployment/#deploying-the-enigma-network","text":"Discovery can currently be deployed in two ways: Developer Mode : a series of containers in a Docker environment. This is also known as \"Simulation Mode\" because it does not require you to have hardware SGX support (meaning yes, you can develop on your macbook!). Hardware Mode : This mode requires hardware-level compatibility (see \"System Requirements\"). This is useful for users who may want to run Secret Nodes. For a step-by-step walkthrough of the \"developer mode\" deployment process, see our Getting Started guide. \ud83e\udd1eDiscovery will be also soon deployed to a public Ethereum testnet, giving you the opportunity to test your applications in the wild on a network of nodes, and streamlining your development options. Stay tuned! \ud83d\udcfa","title":"Deploying the Enigma Network  \ud83d\udce1"},{"location":"IntroductionToEnigmaJS/","text":"Enigma-JS Library \ud83d\udd0d The Enigma-JS Library gives developers the tools to deploy, interact with, and submit tasks to secret contracts on the Enigma network. Tasks are initiated by end-users of Ethereum applications. Enigma-JS enables developers to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. submit tasks to ENG network and receive encrypted outputs that can be decrypted by the user \ud83e\udd1e Note: The Enigma Network has its own secret contracts. The business logic of a computation task is contained in a secret contract, which is deployed on the Enigma Network. This is in contrast to having this logic in the function of an Ethereum smart contract. This is more powerful for many reasons; notably, a secret contract may store an encrypted state. Worker Verification In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. \ud83e\udd1eA worker is an Enigma Node-- it will execute the computation over the data submitted in the task and return an encrypted result. The node-runner does not see the data at any time. Computation Tasks When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks. On-Chain Computation Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas . Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results. Task Verification A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: 1. The current epoch ends 2. A function in the task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. \ud83e\udd1eEthereum does not store the tasks results nor the encrypted state deltas , only hashes from which nodes can verify the integrity of their own data.","title":"About EnigmaJS"},{"location":"IntroductionToEnigmaJS/#enigma-js-library","text":"The Enigma-JS Library gives developers the tools to deploy, interact with, and submit tasks to secret contracts on the Enigma network. Tasks are initiated by end-users of Ethereum applications. Enigma-JS enables developers to: safely encrypt sensitive data in-memory for immediate use or storage create a record of each task on the Ethereum ledger obtain an authoritative cryptographic proof that the target worker is securely running trusted hardware (SGX) prior to sending data to it and paying the corresponding fees. submit tasks to ENG network and receive encrypted outputs that can be decrypted by the user \ud83e\udd1e Note: The Enigma Network has its own secret contracts. The business logic of a computation task is contained in a secret contract, which is deployed on the Enigma Network. This is in contrast to having this logic in the function of an Ethereum smart contract. This is more powerful for many reasons; notably, a secret contract may store an encrypted state.","title":"Enigma-JS Library \ud83d\udd0d"},{"location":"IntroductionToEnigmaJS/#worker-verification","text":"In the first release of Discovery, only one worker is assigned to a smart contract at any given time. A new worker is randomly assigned to a contract at the beginning of each epoch. Before creating a computation task, the Enigma Library verifies the selected worker using the cryptographic proofs included in its SGX report. \ud83e\udd1eA worker is an Enigma Node-- it will execute the computation over the data submitted in the task and return an encrypted result. The node-runner does not see the data at any time.","title":"Worker Verification"},{"location":"IntroductionToEnigmaJS/#computation-tasks","text":"When creating a computation task, the dApp user encrypts all inputs using the Enigma Library: address of the secret contract function signature input parameters for payable functions, the ERC20 tokens to transfer the computation fee Then, the Enigma Library creates an Ethereum transaction containing a record of the task. The record simply contains a hash of all inputs and some metadata about the task. It contains as little data as possible to minimize the Ethereum storage fee. The task record is the primary source truth for each task. It will be used by the Enigma Network to verify inputs and the order of tasks.","title":"Computation Tasks"},{"location":"IntroductionToEnigmaJS/#on-chain-computation","text":"Once the task record transaction is submitted, the Enigma Library broadcasts the task data to the Enigma Network via its user node, the Enigma Network node that the dApp user connects to. The task data message is propagated to each node in the network. Upon receiving the message, the selected worker: verifies the task inputs against the task record computes the task Since secret contracts are stateful, the selected worker keeps an up-to-date copy of the state in memory. State updates are propagated to all nodes in the form of encrypted state deltas . Each node keeps the state deltas in an ordered list from which the full state can be reconstituted. After each computation, the results are encrypted and propagated to the network. The Enigma Library watches for the results.","title":"On-Chain Computation"},{"location":"IntroductionToEnigmaJS/#task-verification","text":"A computation task is only confirmed after verification on Ethereum. After computing a task, the selected worker commits a task receipt linked the task record. Workers process tasks in batches instead of committing every task to Ethereum immediately. These are the triggers to commit tasks: 1. The current epoch ends 2. A function in the task calls an Ethereum smart contract When either trigger occurs, the worker commits a batch of all unconfirmed tasks stored locally. \ud83e\udd1eEthereum does not store the tasks results nor the encrypted state deltas , only hashes from which nodes can verify the integrity of their own data.","title":"Task Verification"},{"location":"IntroductionToReference/","text":"Reference Documentation \ud83d\udcd6 Enigma Smart Contract and Library This repository includes the JavaScript Enigma Library, which provides the interface that secret contract and dApp developers use to interact with the Enigma protocol. The source code is written in ECMAScript 6 (ES6) and comes prebundled with Webpack, and is exported in UMD format to provide universal functionality. The repository also includes more than 100 unit tests that both provide up to 98% code coverage, as well as comprehensively describes the functions provided both by the Enigma Library and the Enigma Contract. This repository also includes the Enigma smart contract written in Solidity, which implements the consensus layer for the Discovery release of the Enigma Protocol. Due to the limitations of EVM (Etherium Virtual Machine) as well as the complexity of the contract itself, several components have been broken down into modular contracts and libraries that come together into what is referred to as the Enigma Contract . One instance of this contract will be first deployed on the Ethereum testnet, and once more later on mainnet release. Enigma Core The code of this repository, as its name would imply, lies at the core of the Enigma Protocol. Written in Rust, it includes the code that runs both the inside (trusted) of the enclave and the outside (untrusted), and is responsible for interfacing with the rest of the Enigma Network. This repository also includes the Principal Node that runs inside a trusted enclave, and manages the keys to encrypt the state for all contracts in each epoch. It responds to legitimate requests from all other enclaves in the Enigma network for the encryption keys assigned to any such nodes. Both the enclaves and the principal node come packaged with support for 'simulation mode'. This mode allows for dApp developers to test secret contracts and interact with the libraries in a non-live environment without Intel SGX enabled hardware, thus allowing for easier cross-platform and legacy support. Please note that once the Enigma network has been deployed on testnet and mainnet, only enclaves running in hardware mode (on hosts with SGX enabled) will be able to join the Enigma network. Enigma Peer-to-Peer (P2P) Written in Javascript and forking off libp2p, this repository provides each of the above described enclaves with the peer-to-peer network functionality, thus forming the decentralised network. While both Enigma-Core and Enigma-P2P typically run on the same host, they are divided into two separate repositories for two reasons: provide very different functionality, and are coded in different languages (Rust and Javascript, respectively). Enigma-P2P runs in Node.js and provides a command line interface (CLI), although it is most commonly initialised automatically from a configuration file. The Enigma-P2P packages various autonomous runtimes that communicate between each other through a main controller. This communication is facilitated via both bi-directional message-sending tunnels called channels , as well as through actions , which are predefined messages that have a specific function attached to them. This infrastructure is optimized for asynchronous communication that reacts in real-time to notifications sent between the various components. This repository organizes its code into various cargo crates, providing several different components: the Enigma implementation of the WebAssembly (WASM) interpreter in Rust, the Enigma Runtime, cryptographic (AES, ECDSA, ECDH) and hashing (Keccak256) libraries, as well as the Remote Attestation client.","title":"About Reference"},{"location":"IntroductionToReference/#reference-documentation","text":"","title":"Reference Documentation \ud83d\udcd6"},{"location":"IntroductionToReference/#enigma-smart-contract-and-library","text":"This repository includes the JavaScript Enigma Library, which provides the interface that secret contract and dApp developers use to interact with the Enigma protocol. The source code is written in ECMAScript 6 (ES6) and comes prebundled with Webpack, and is exported in UMD format to provide universal functionality. The repository also includes more than 100 unit tests that both provide up to 98% code coverage, as well as comprehensively describes the functions provided both by the Enigma Library and the Enigma Contract. This repository also includes the Enigma smart contract written in Solidity, which implements the consensus layer for the Discovery release of the Enigma Protocol. Due to the limitations of EVM (Etherium Virtual Machine) as well as the complexity of the contract itself, several components have been broken down into modular contracts and libraries that come together into what is referred to as the Enigma Contract . One instance of this contract will be first deployed on the Ethereum testnet, and once more later on mainnet release.","title":"Enigma Smart Contract and Library"},{"location":"IntroductionToReference/#enigma-core","text":"The code of this repository, as its name would imply, lies at the core of the Enigma Protocol. Written in Rust, it includes the code that runs both the inside (trusted) of the enclave and the outside (untrusted), and is responsible for interfacing with the rest of the Enigma Network. This repository also includes the Principal Node that runs inside a trusted enclave, and manages the keys to encrypt the state for all contracts in each epoch. It responds to legitimate requests from all other enclaves in the Enigma network for the encryption keys assigned to any such nodes. Both the enclaves and the principal node come packaged with support for 'simulation mode'. This mode allows for dApp developers to test secret contracts and interact with the libraries in a non-live environment without Intel SGX enabled hardware, thus allowing for easier cross-platform and legacy support. Please note that once the Enigma network has been deployed on testnet and mainnet, only enclaves running in hardware mode (on hosts with SGX enabled) will be able to join the Enigma network.","title":"Enigma Core"},{"location":"IntroductionToReference/#enigma-peer-to-peer-p2p","text":"Written in Javascript and forking off libp2p, this repository provides each of the above described enclaves with the peer-to-peer network functionality, thus forming the decentralised network. While both Enigma-Core and Enigma-P2P typically run on the same host, they are divided into two separate repositories for two reasons: provide very different functionality, and are coded in different languages (Rust and Javascript, respectively). Enigma-P2P runs in Node.js and provides a command line interface (CLI), although it is most commonly initialised automatically from a configuration file. The Enigma-P2P packages various autonomous runtimes that communicate between each other through a main controller. This communication is facilitated via both bi-directional message-sending tunnels called channels , as well as through actions , which are predefined messages that have a specific function attached to them. This infrastructure is optimized for asynchronous communication that reacts in real-time to notifications sent between the various components. This repository organizes its code into various cargo crates, providing several different components: the Enigma implementation of the WebAssembly (WASM) interpreter in Rust, the Enigma Runtime, cryptographic (AES, ECDSA, ECDH) and hashing (Keccak256) libraries, as well as the Remote Attestation client.","title":"Enigma Peer-to-Peer (P2P)"},{"location":"KeyManagement/","text":"Key Management \ud83d\udddd\ufe0f The end-user of a dApp is provided with encryption keys when they interact with a secret contract. TODO Where are the keys stored How can users access the keys When might a user need to access the keys What enigma-js functions are related to user's key-management? What kind of keys are they / what are their features? This enables private outputs.","title":"Key Management  \ud83d\udddd\ufe0f"},{"location":"KeyManagement/#key-management","text":"The end-user of a dApp is provided with encryption keys when they interact with a secret contract. TODO Where are the keys stored How can users access the keys When might a user need to access the keys What enigma-js functions are related to user's key-management? What kind of keys are they / what are their features? This enables private outputs.","title":"Key Management  \ud83d\udddd\ufe0f"},{"location":"NewForDiscovery/","text":"What's New in Discovery \ud83c\udf81 The Discovery release of the Enigma protocol provides the following features: Secret State Secret contracts are capable of maintaining a state. Encrypted data persists across separate private computations or different tasks. Stateful contracts enable many more use cases than stateless computations (like secret tokens). Secret Contracts are seperate from Smart Contracts The Enigma network performs computation and storage, using Ethereum only for consensus and a shared ledger. This means that secret contracts have their own runtime (modified EVM) and programming language (Rust, instead of Solidity). Private Outputs In addition to private inputs, the network now supports storage of computation outputs. The contract state is stored (encrypted) on-chain and results can be encrypted directly for the dApp user. Economic Incentives Each node receives a financial reward for participating in the network. Gas Cost Optimization On Ethereum, gas cost is based on computation units associated with each opcode . The STORAGEADD opcode is the most expensive at 20k gas for each 32 bytes of data. Secret contracts should be significantly cheaper in gas than they were in the previous MVT release due to the following modifications: Inputs are not stored in the contract, only the taskId (a hash of inputs). The taskId is generated from inputs in the worker\u2019s enclave to ensure their integrity Outputs are not stored in the contract. On chain verification of the results still takes place but using a hash of the results. Ethereum Integration These features maintain interoperability with Ethereum: Token Transfers : Calling a payable secret contract function may involve an arbitrary ERC20 token deposit. Tokens are locked in the contract state until explicitly transferred to an Ethereum address in the secret contract business logic. Function Calls : Secret Contracts may call arbitrary functions of smart contract deployed on Ethereum. Contract Attributes Discovery supports the storage of system attributes (metadata) about each contract. To illustrate their utility, these attributes include but may not be limited to: A list of workers assigned to each contract which is useful for key management. The contract bytecode (or a reference to it) A mapping between each attribute and its position in the state array. Reference to external storage (like s3 or IPFS) if we build support for sealed data stored externally.","title":"About Discovery"},{"location":"NewForDiscovery/#whats-new-in-discovery","text":"The Discovery release of the Enigma protocol provides the following features:","title":"What's New in Discovery \ud83c\udf81"},{"location":"NewForDiscovery/#secret-state","text":"Secret contracts are capable of maintaining a state. Encrypted data persists across separate private computations or different tasks. Stateful contracts enable many more use cases than stateless computations (like secret tokens).","title":"Secret State"},{"location":"NewForDiscovery/#secret-contracts-are-seperate-from-smart-contracts","text":"The Enigma network performs computation and storage, using Ethereum only for consensus and a shared ledger. This means that secret contracts have their own runtime (modified EVM) and programming language (Rust, instead of Solidity).","title":"Secret Contracts are seperate from Smart Contracts"},{"location":"NewForDiscovery/#private-outputs","text":"In addition to private inputs, the network now supports storage of computation outputs. The contract state is stored (encrypted) on-chain and results can be encrypted directly for the dApp user.","title":"Private Outputs"},{"location":"NewForDiscovery/#economic-incentives","text":"Each node receives a financial reward for participating in the network.","title":"Economic Incentives"},{"location":"NewForDiscovery/#gas-cost-optimization","text":"On Ethereum, gas cost is based on computation units associated with each opcode . The STORAGEADD opcode is the most expensive at 20k gas for each 32 bytes of data. Secret contracts should be significantly cheaper in gas than they were in the previous MVT release due to the following modifications: Inputs are not stored in the contract, only the taskId (a hash of inputs). The taskId is generated from inputs in the worker\u2019s enclave to ensure their integrity Outputs are not stored in the contract. On chain verification of the results still takes place but using a hash of the results.","title":"Gas Cost Optimization"},{"location":"NewForDiscovery/#ethereum-integration","text":"These features maintain interoperability with Ethereum: Token Transfers : Calling a payable secret contract function may involve an arbitrary ERC20 token deposit. Tokens are locked in the contract state until explicitly transferred to an Ethereum address in the secret contract business logic. Function Calls : Secret Contracts may call arbitrary functions of smart contract deployed on Ethereum.","title":"Ethereum Integration"},{"location":"NewForDiscovery/#contract-attributes","text":"Discovery supports the storage of system attributes (metadata) about each contract. To illustrate their utility, these attributes include but may not be limited to: A list of workers assigned to each contract which is useful for key management. The contract bytecode (or a reference to it) A mapping between each attribute and its position in the state array. Reference to external storage (like s3 or IPFS) if we build support for sealed data stored externally.","title":"Contract Attributes"},{"location":"RustResources/","text":"Other Rust Resources \ud83d\uddfa\ufe0f Learning a new language is an investment, and we think Rust is well worth it. Here are some resources to get you up to speed and building with Rust. The Rust Book A concise, and often light-hearted primer and reference resource.","title":"Other Rust Resources \ud83d\uddfa\ufe0f"},{"location":"RustResources/#other-rust-resources","text":"Learning a new language is an investment, and we think Rust is well worth it. Here are some resources to get you up to speed and building with Rust. The Rust Book A concise, and often light-hearted primer and reference resource.","title":"Other Rust Resources \ud83d\uddfa\ufe0f"},{"location":"RustWalkthrough/","text":"An Introduction to Rust To help developers who are new to Rust or the Enigma protocol get a firm understanding of how secret contracts are written, this section outlines how to write a standalone Rust program that will be used to solve a classic connundrum - Yao's Millionaire Problem . To begin, you will need to ensure that you have Rust installed on your system, as well as a basic understanding of how Cargo operates. Note that there are several Rust features and concepts mentioned in the sections below, some of which only lightly touched on - if you would like to learn more about syntax or the language itself, it is recomended to consult the open-source Rust Book , which contains a variety of great examples and explanations curated by the community itself. For the full source code of the program below, see this repository . Setting Up In your terminal, issue the command cargo new rust_millionaires_problem to create a new project. Enter your new project directory with the command cd rust_millionaires_problem . Within this new directory there is a file named Cargo.toml . This is your project manifest , and it contains information about the author, versioning and dependencies. This should have been autopopulated from your Rust installation, though ensure the contents are similar to this: [package] name = rust_millionaires_demo version = 0.1.0 authors = [ name email ] [dependencies] Program Design As with all programs, we must break down the problem at hand and address each component individually. The intended logic is depicted in the graphic below. This basic flow can be represented in four steps: Creating a new Millionaires\u2019 Problem (this object should maintain a list of millionaires) Add millionaire 1 (object containing address / net worth) with name Bob and net worth 1,000,000 Add millionaire 2 (object containing address / net worth) with name Alice and net worth 2,000,000 Compute the richest millionaire, returning the appropriate address/name Writing your Program Data Structs Structs are data types that let you package together multiple related values and reference them with attribute fields and one collective name. To begin writing our program, we will be implementing a struct that will represent the Millionaires Problem itself. To create this struct, open src/lib.rs in your text editor and replace the contents with the following: pub struct MillionairesProblem { millionaires: Vec Millionaire , } This implements a basic struct with a single field named Millionaire . Next, a second struct must be implemented to represent the individual millionaires. This time two attribute fields will be added, one to track each millionaires address, and the other for net worth. pub struct Millionaire { address: String, // field name : field type net_worth: u64, // field name : field type } Function and Method Implementation We must now implement our programs primary logic - generating the millionaires problem itself. To do this we create a function , and place it inside a implementation block like so: impl MillionairesProblem { pub fn new() - MillionairesProblem { MillionairesProblem { millionaires: Vec::new(), } } } The last line of this section creates an empty vector when the Millionaires Problem is initialised. Also note that the impl block has the same name as the MillionairesProblem struct we defined above, and thus functions and methods we implement here refer to the same context. Adding a Millionaire In order to add a new millionaire, we will define a method in the impl block like this: pub fn add_millionaire( mut self, address: String, net_worth: u64) { let millionaire = Millionaire { address, net_worth, }; self.millionaires.push(millionaire); } NOTE: Methods, unlike traditional functions and associated functions, always start with self as the first parameter, which represents the instance of the struct this method is being called on. In this case, we prefix self with mut . The touches upon the topic of ownership , a big contributor to Rusts memory efficiency. It is reccomended to take the time to understand ownership, and how it can improve your development experience down the road. Computing the Richest Millionaire The final method we will write is to compute the richest millionaire. pub fn compute_richest( self) - str { match self.millionaires.iter().max_by_key(|m| m.net_worth) { Some(millionaire) = millionaire.address[..], None = None } } Summary Congratulations, you've just made your first secret contract library! To summarize, we first created two structs: MillionairesProblem and Millionaire , then created an impl block to further the functionality of the MillionairesProblem , and two methods to allow us to add a new millionaire and compute the richest millionaire.","title":"Learn Rust"},{"location":"RustWalkthrough/#an-introduction-to-rust","text":"To help developers who are new to Rust or the Enigma protocol get a firm understanding of how secret contracts are written, this section outlines how to write a standalone Rust program that will be used to solve a classic connundrum - Yao's Millionaire Problem . To begin, you will need to ensure that you have Rust installed on your system, as well as a basic understanding of how Cargo operates. Note that there are several Rust features and concepts mentioned in the sections below, some of which only lightly touched on - if you would like to learn more about syntax or the language itself, it is recomended to consult the open-source Rust Book , which contains a variety of great examples and explanations curated by the community itself. For the full source code of the program below, see this repository .","title":"An Introduction to Rust"},{"location":"RustWalkthrough/#setting-up","text":"In your terminal, issue the command cargo new rust_millionaires_problem to create a new project. Enter your new project directory with the command cd rust_millionaires_problem . Within this new directory there is a file named Cargo.toml . This is your project manifest , and it contains information about the author, versioning and dependencies. This should have been autopopulated from your Rust installation, though ensure the contents are similar to this: [package] name = rust_millionaires_demo version = 0.1.0 authors = [ name email ] [dependencies]","title":"Setting Up"},{"location":"RustWalkthrough/#program-design","text":"As with all programs, we must break down the problem at hand and address each component individually. The intended logic is depicted in the graphic below. This basic flow can be represented in four steps: Creating a new Millionaires\u2019 Problem (this object should maintain a list of millionaires) Add millionaire 1 (object containing address / net worth) with name Bob and net worth 1,000,000 Add millionaire 2 (object containing address / net worth) with name Alice and net worth 2,000,000 Compute the richest millionaire, returning the appropriate address/name","title":"Program Design"},{"location":"RustWalkthrough/#writing-your-program","text":"","title":"Writing your Program"},{"location":"RustWalkthrough/#data-structs","text":"Structs are data types that let you package together multiple related values and reference them with attribute fields and one collective name. To begin writing our program, we will be implementing a struct that will represent the Millionaires Problem itself. To create this struct, open src/lib.rs in your text editor and replace the contents with the following: pub struct MillionairesProblem { millionaires: Vec Millionaire , } This implements a basic struct with a single field named Millionaire . Next, a second struct must be implemented to represent the individual millionaires. This time two attribute fields will be added, one to track each millionaires address, and the other for net worth. pub struct Millionaire { address: String, // field name : field type net_worth: u64, // field name : field type }","title":"Data Structs"},{"location":"RustWalkthrough/#function-and-method-implementation","text":"We must now implement our programs primary logic - generating the millionaires problem itself. To do this we create a function , and place it inside a implementation block like so: impl MillionairesProblem { pub fn new() - MillionairesProblem { MillionairesProblem { millionaires: Vec::new(), } } } The last line of this section creates an empty vector when the Millionaires Problem is initialised. Also note that the impl block has the same name as the MillionairesProblem struct we defined above, and thus functions and methods we implement here refer to the same context.","title":"Function and Method Implementation"},{"location":"RustWalkthrough/#adding-a-millionaire","text":"In order to add a new millionaire, we will define a method in the impl block like this: pub fn add_millionaire( mut self, address: String, net_worth: u64) { let millionaire = Millionaire { address, net_worth, }; self.millionaires.push(millionaire); } NOTE: Methods, unlike traditional functions and associated functions, always start with self as the first parameter, which represents the instance of the struct this method is being called on. In this case, we prefix self with mut . The touches upon the topic of ownership , a big contributor to Rusts memory efficiency. It is reccomended to take the time to understand ownership, and how it can improve your development experience down the road.","title":"Adding a Millionaire"},{"location":"RustWalkthrough/#computing-the-richest-millionaire","text":"The final method we will write is to compute the richest millionaire. pub fn compute_richest( self) - str { match self.millionaires.iter().max_by_key(|m| m.net_worth) { Some(millionaire) = millionaire.address[..], None = None } }","title":"Computing the Richest Millionaire"},{"location":"RustWalkthrough/#summary","text":"Congratulations, you've just made your first secret contract library! To summarize, we first created two structs: MillionairesProblem and Millionaire , then created an impl block to further the functionality of the MillionairesProblem , and two methods to allow us to add a new millionaire and compute the richest millionaire.","title":"Summary"},{"location":"SecretContractEngine/","text":"Secret Contract Engine \ud83d\ude82 Secret contracts are written in Rust and compiled to WebAssembly (abbreviated Wasm). The contract bytecode is stored unencrypted on Enigma with a hash on Ethereum. The hash of the bytecode will be used as its address. Benefits of this stack include: Well suited to execute general purpose tasks (e.g. machine learning algorithms) compared to a smart-contract-specific language like Solidity. Existing Parity pwasm implementation that can be used as a reference or partially reused. Contracts will be written in Rust which is consistent with our stack and that of other blockchains. Using a general purpose language and execution environment enables us to extend the smart contract features simply by creating new libraries. For example, we could create a library which executes web queries directly in the secret contract business logic. Contract Architecture We use wasmi - Parity WASM interpreter, which allows us to run general-purpose Wasm code. Baidu already did an adaptation of wasmi to SGX. We create Enigma runtime module for handling all state operations, and eng_wasm, which is an implementation of bindings to Enigma runtime. As required by wasmi, we create ImportResolver, which maps all functions that runtime supports to the corresponding contract import entries. We decided to use Solidity ABI format for input/output for the following reasons: Pwasm implementation uses Solidity ABI as well and may be reused. Ability to preserve the current functionality with Solidity contracts that use Solidity ABI. Despite the restrictions of the Solidity ABI types, the new version V2 should support more types, for example structs Technical Specification Structure For usage of runtime predefined module eng_wasm should be imported, which defines all operations on state. Constructor function to be called upon contract creation Functions Other requirements: Users should not write a \u201cmain\u201d call function in contract (like in pwasm). Contract-to-contract calls are not allowed except when at the end of the execution we want to call a contract on Ethereum. For this we can re-use what we did for a callback in MVT or what Parity does for intercalls. Gas calculation: We intend to reuse Parity mechanism of injection of the gas calculation into a contract. We prefer to build a mechanism that executes the computation while there is enough gas, and stops the execution otherwise. If this is difficult, maybe it\u2019s ok to do the gas calculation after the computation (although with some reasonable limits - halting problem) Compatibility: We decided to preserve the current functionality with Solidity contracts The Solidity contract compiled to EVM will be deployed on ethereum and on Enigma. For stateful functions users will create regular ethereum call transactions. For stateless functions there will be an additional option: to call the function through Enigma network as it is done in the case of Wasm contract. Since in both cases we use Solidity ABI, the call seems the same from the network perspective. The challenge: in the case of Solidity contract it is important not only to return results of the call to the user, but also to commit them on ethereum (for example in the case of secret voting).","title":"Secret Contract Engine"},{"location":"SecretContractEngine/#secret-contract-engine","text":"Secret contracts are written in Rust and compiled to WebAssembly (abbreviated Wasm). The contract bytecode is stored unencrypted on Enigma with a hash on Ethereum. The hash of the bytecode will be used as its address. Benefits of this stack include: Well suited to execute general purpose tasks (e.g. machine learning algorithms) compared to a smart-contract-specific language like Solidity. Existing Parity pwasm implementation that can be used as a reference or partially reused. Contracts will be written in Rust which is consistent with our stack and that of other blockchains. Using a general purpose language and execution environment enables us to extend the smart contract features simply by creating new libraries. For example, we could create a library which executes web queries directly in the secret contract business logic.","title":"Secret Contract Engine \ud83d\ude82"},{"location":"SecretContractEngine/#contract-architecture","text":"We use wasmi - Parity WASM interpreter, which allows us to run general-purpose Wasm code. Baidu already did an adaptation of wasmi to SGX. We create Enigma runtime module for handling all state operations, and eng_wasm, which is an implementation of bindings to Enigma runtime. As required by wasmi, we create ImportResolver, which maps all functions that runtime supports to the corresponding contract import entries. We decided to use Solidity ABI format for input/output for the following reasons: Pwasm implementation uses Solidity ABI as well and may be reused. Ability to preserve the current functionality with Solidity contracts that use Solidity ABI. Despite the restrictions of the Solidity ABI types, the new version V2 should support more types, for example structs","title":"Contract Architecture"},{"location":"SecretContractEngine/#technical-specification","text":"Structure For usage of runtime predefined module eng_wasm should be imported, which defines all operations on state. Constructor function to be called upon contract creation Functions Other requirements: Users should not write a \u201cmain\u201d call function in contract (like in pwasm). Contract-to-contract calls are not allowed except when at the end of the execution we want to call a contract on Ethereum. For this we can re-use what we did for a callback in MVT or what Parity does for intercalls. Gas calculation: We intend to reuse Parity mechanism of injection of the gas calculation into a contract. We prefer to build a mechanism that executes the computation while there is enough gas, and stops the execution otherwise. If this is difficult, maybe it\u2019s ok to do the gas calculation after the computation (although with some reasonable limits - halting problem) Compatibility: We decided to preserve the current functionality with Solidity contracts The Solidity contract compiled to EVM will be deployed on ethereum and on Enigma. For stateful functions users will create regular ethereum call transactions. For stateless functions there will be an additional option: to call the function through Enigma network as it is done in the case of Wasm contract. Since in both cases we use Solidity ABI, the call seems the same from the network perspective. The challenge: in the case of Solidity contract it is important not only to return results of the call to the user, but also to commit them on ethereum (for example in the case of secret voting).","title":"Technical Specification"},{"location":"SecretContractExamples/","text":"Examples \u26f7\ufe0f Millionaire's Problem Secret ERC-20 Token https://github.com/enigmampc/enigma-core-internal/blob/develop/examples/eng_wasm_contracts/erc20/src/lib.rs Calculator Voting Coin Toss","title":"Examples"},{"location":"SecretContractExamples/#examples","text":"","title":"Examples \u26f7\ufe0f"},{"location":"SecretContractExamples/#millionaires-problem","text":"","title":"Millionaire's Problem"},{"location":"SecretContractExamples/#secret-erc-20-token","text":"https://github.com/enigmampc/enigma-core-internal/blob/develop/examples/eng_wasm_contracts/erc20/src/lib.rs","title":"Secret ERC-20 Token"},{"location":"SecretContractExamples/#calculator","text":"","title":"Calculator"},{"location":"SecretContractExamples/#voting","text":"","title":"Voting"},{"location":"SecretContractExamples/#coin-toss","text":"","title":"Coin Toss"},{"location":"SecretContractWalkthrough/","text":"Creating a Secret Contract \ud83d\udcd0 Adi's secret contract walkthrough","title":"Write a Secret Contract"},{"location":"SecretContractWalkthrough/#creating-a-secret-contract","text":"Adi's secret contract walkthrough","title":"Creating a Secret Contract \ud83d\udcd0"},{"location":"SecretContracts/","text":"Secret Contracts \ud83e\udd2b Secret contracts are self-executing contracts with encrypted inputs and outputs. Once deployed on the Enigma network, they are called by the end-users of decentralized applications and executed by Enigma nodes. Enigma Secret Contracts are written in Rust. If you are not familiar with Rust, check out our walkthrough (which will also take you through developing your first Secret Contract). We highly encourage the walkthrough for first-time users. \ud83e\udd1e Enigma Secret Contract (ESC) Development Environment \ud83c\udf31 The ESC environment includes eng_wasm crate, which implements: A bridge to Enigma runtime; Utilities for generating code that implements calls to the exported ESC\u2019s functions and calls from ESC to Ethereum contracts. In the future this crate will be populated through crates.io, and then ESC may be created and built on any client satisfying the following requirements: Nightly Rust language installed wasm32-unknown-unknown target installed ( link ) This means that once you have written your secret contract as per the guidelines below, you will compile it with the following command: cargo build --release --target wasm32-unknown-unknown Which will put the compiled library under: target/wasm32-unknown-unknown/release/contract_name.wasm Today the easiest way to create ESC is to create it as part of enigma-core-internal project. There is a directory called examples under the root directory. Here you can see the examples of the existing ESCs and here you can add your own examples. ESC should be Rust dynamic library crate: It should contain src/lib.rs file as its main file In Cargo.toml the following should be defined: [lib] crate-type = [\u201ccdylib\u201d] Reference : This section instructs the compiler to produce a dynamic system library to be loaded from another language. This output type will create *.so files on Linux, *.dylib files on macOS, and *.dll files on Windows. Additional requirements: - At the root level add .cargo/config with the following content: [build] target = \u201cwasm32-unknown-unknown\u201d Cargo.toml: [dependencies] eng_wasm = { path = \u201c../../../eng-wasm\u201d] eng_wasm_derive = { path = \u201c../../../eng-wasm/derive\u201d ] [profile.release] panic = \u201cabort\u201d lto = true opt-level = \u201cz\u201d","title":"Overview"},{"location":"SecretContracts/#secret-contracts","text":"Secret contracts are self-executing contracts with encrypted inputs and outputs. Once deployed on the Enigma network, they are called by the end-users of decentralized applications and executed by Enigma nodes. Enigma Secret Contracts are written in Rust. If you are not familiar with Rust, check out our walkthrough (which will also take you through developing your first Secret Contract). We highly encourage the walkthrough for first-time users. \ud83e\udd1e","title":"Secret Contracts \ud83e\udd2b"},{"location":"SecretContracts/#enigma-secret-contract-esc-development-environment","text":"The ESC environment includes eng_wasm crate, which implements: A bridge to Enigma runtime; Utilities for generating code that implements calls to the exported ESC\u2019s functions and calls from ESC to Ethereum contracts. In the future this crate will be populated through crates.io, and then ESC may be created and built on any client satisfying the following requirements: Nightly Rust language installed wasm32-unknown-unknown target installed ( link ) This means that once you have written your secret contract as per the guidelines below, you will compile it with the following command: cargo build --release --target wasm32-unknown-unknown Which will put the compiled library under: target/wasm32-unknown-unknown/release/contract_name.wasm Today the easiest way to create ESC is to create it as part of enigma-core-internal project. There is a directory called examples under the root directory. Here you can see the examples of the existing ESCs and here you can add your own examples. ESC should be Rust dynamic library crate: It should contain src/lib.rs file as its main file In Cargo.toml the following should be defined: [lib] crate-type = [\u201ccdylib\u201d] Reference : This section instructs the compiler to produce a dynamic system library to be loaded from another language. This output type will create *.so files on Linux, *.dylib files on macOS, and *.dll files on Windows. Additional requirements: - At the root level add .cargo/config with the following content: [build] target = \u201cwasm32-unknown-unknown\u201d Cargo.toml: [dependencies] eng_wasm = { path = \u201c../../../eng-wasm\u201d] eng_wasm_derive = { path = \u201c../../../eng-wasm/derive\u201d ] [profile.release] panic = \u201cabort\u201d lto = true opt-level = \u201cz\u201d","title":"Enigma Secret Contract (ESC) Development Environment \ud83c\udf31"},{"location":"Walkthrough/","text":"Start Here \ud83d\udccd Discovery-cli is a Command Line Interface (CLI) for the Discovery Enigma Protocol development environment, and is the fastest way to get up and running with Enigma. This interface comes with application scaffolding to get you started with writing and deploying secret contracts. After you set up the network, see our Walkthrough sections for additional guidance. Installation npm install -g @enigmampc/discovery-cli Usage $ discovery command Commands: discovery init Initialize Enigma Discovery development environment discovery compile Compile Secret Contracts and Smart Contracts discovery migrate Migrate Secret Contracts and Smart Contracts discovery pull Pull the latest images for the containers in the network discovery start Launch the Discovery Docker network discovery stop Stop the network by stopping and removing all containers Options: --help Show help [boolean] --version Show version number [boolean] Uninstall npm remove -g @enigmampc/discovery-cli","title":"Quick Start"},{"location":"Walkthrough/#start-here","text":"Discovery-cli is a Command Line Interface (CLI) for the Discovery Enigma Protocol development environment, and is the fastest way to get up and running with Enigma. This interface comes with application scaffolding to get you started with writing and deploying secret contracts. After you set up the network, see our Walkthrough sections for additional guidance.","title":"Start Here \ud83d\udccd"},{"location":"Walkthrough/#installation","text":"npm install -g @enigmampc/discovery-cli","title":"Installation"},{"location":"Walkthrough/#usage","text":"$ discovery command Commands: discovery init Initialize Enigma Discovery development environment discovery compile Compile Secret Contracts and Smart Contracts discovery migrate Migrate Secret Contracts and Smart Contracts discovery pull Pull the latest images for the containers in the network discovery start Launch the Discovery Docker network discovery stop Stop the network by stopping and removing all containers Options: --help Show help [boolean] --version Show version number [boolean]","title":"Usage"},{"location":"Walkthrough/#uninstall","text":"npm remove -g @enigmampc/discovery-cli","title":"Uninstall"},{"location":"WhyRust/","text":"Why Rust? \u2699\ufe0f Rust is an excellent programming language that simultaneously optimizes for both safety and performance in a way few languages can claim. The Rust core team has created a language that allows for veteran developers and newcomers alike to develop production-ready, systems-level code. Performance \ud83c\udfce\ufe0f Rust features a unique and powerful combination of the cargo package manager (overlooked in higher level languages), zero-cost abstractions , memory management that is both manual and smart in nature (thereby avoiding both the runtime garbage collection costs you find in Python and Ruby as well as the error-prone nature of manual management in C and C++), and many other features. Safety \ud83d\udc77 The strict compilation checks and error explanations Rust offers prevent large classes of common errors, supporting safe and performant code. Community \ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1 Last, but certainly not least, there is a wonderful community of Rustaceans (a weird, but endearing term that will grow on you over time) that will support whatever your journey may be. Joining this community puts you in good company\u200a\u2014\u200aas one recent survey shows, Rust has been voted the most loved programming language for the third year in a row!","title":"Why Rust? \u2699\ufe0f"},{"location":"WhyRust/#why-rust","text":"Rust is an excellent programming language that simultaneously optimizes for both safety and performance in a way few languages can claim. The Rust core team has created a language that allows for veteran developers and newcomers alike to develop production-ready, systems-level code.","title":"Why Rust? \u2699\ufe0f"},{"location":"WhyRust/#performance","text":"Rust features a unique and powerful combination of the cargo package manager (overlooked in higher level languages), zero-cost abstractions , memory management that is both manual and smart in nature (thereby avoiding both the runtime garbage collection costs you find in Python and Ruby as well as the error-prone nature of manual management in C and C++), and many other features.","title":"Performance \ud83c\udfce\ufe0f"},{"location":"WhyRust/#safety","text":"The strict compilation checks and error explanations Rust offers prevent large classes of common errors, supporting safe and performant code.","title":"Safety \ud83d\udc77"},{"location":"WhyRust/#community","text":"Last, but certainly not least, there is a wonderful community of Rustaceans (a weird, but endearing term that will grow on you over time) that will support whatever your journey may be. Joining this community puts you in good company\u200a\u2014\u200aas one recent survey shows, Rust has been voted the most loved programming language for the third year in a row!","title":"Community \ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1"}]}